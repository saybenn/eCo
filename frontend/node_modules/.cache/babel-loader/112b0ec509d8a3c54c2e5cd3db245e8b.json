{"ast":null,"code":"/**!\n* tippy.js v5.2.1\n* (c) 2017-2020 atomiks\n* MIT License\n*/\nimport { e as errorWhen, _ as _extends, d as defaultProps, t as tippy, a as div, r as removeProperties, n as normalizeToArray, i as includes, s as setVisibilityState, w as warnWhen, B as BACKDROP_CLASS, g as getOwnerDocument, b as isMouseEvent, u as useIfDefined, c as currentInput, f as closestCallback, h as getBasePlacement, j as arrayFrom } from './tippy.chunk.esm.js';\nexport { l as createTippyWithPlugins, t as default, k as hideAll, R as roundArrow } from './tippy.chunk.esm.js';\nimport 'popper.js';\n/**\n * Re-uses a single tippy element for many different tippy instances.\n * Replaces v4's `tippy.group()`.\n */\n\nvar createSingleton = function createSingleton(tippyInstances, optionalProps,\n/** @deprecated use Props.plugins */\nplugins) {\n  if (optionalProps === void 0) {\n    optionalProps = {};\n  }\n\n  if (plugins === void 0) {\n    plugins = [];\n  }\n\n  if (process.env.NODE_ENV !== \"production\") {\n    errorWhen(!Array.isArray(tippyInstances), ['The first argument passed to createSingleton() must be an array of tippy', 'instances. The passed value was', String(tippyInstances)].join(' '));\n  }\n\n  plugins = optionalProps.plugins || plugins;\n  tippyInstances.forEach(function (instance) {\n    instance.disable();\n  });\n\n  var userAria = _extends({}, defaultProps, {}, optionalProps).aria;\n\n  var currentAria;\n  var currentTarget;\n  var shouldSkipUpdate = false;\n  var references = tippyInstances.map(function (instance) {\n    return instance.reference;\n  });\n  var singleton = {\n    fn: function fn(instance) {\n      function handleAriaDescribedByAttribute(isShow) {\n        if (!currentAria) {\n          return;\n        }\n\n        var attr = \"aria-\" + currentAria;\n\n        if (isShow && !instance.props.interactive) {\n          currentTarget.setAttribute(attr, instance.popperChildren.tooltip.id);\n        } else {\n          currentTarget.removeAttribute(attr);\n        }\n      }\n\n      return {\n        onAfterUpdate: function onAfterUpdate(_, _ref) {\n          var aria = _ref.aria; // Ensure `aria` for the singleton instance stays `null`, while\n          // changing the `userAria` value\n\n          if (aria !== undefined && aria !== userAria) {\n            if (!shouldSkipUpdate) {\n              userAria = aria;\n            } else {\n              shouldSkipUpdate = true;\n              instance.setProps({\n                aria: null\n              });\n              shouldSkipUpdate = false;\n            }\n          }\n        },\n        onDestroy: function onDestroy() {\n          tippyInstances.forEach(function (instance) {\n            instance.enable();\n          });\n        },\n        onMount: function onMount() {\n          handleAriaDescribedByAttribute(true);\n        },\n        onUntrigger: function onUntrigger() {\n          handleAriaDescribedByAttribute(false);\n        },\n        onTrigger: function onTrigger(_, event) {\n          var target = event.currentTarget;\n          var index = references.indexOf(target); // bail-out\n\n          if (target === currentTarget) {\n            return;\n          }\n\n          currentTarget = target;\n          currentAria = userAria;\n\n          if (instance.state.isVisible) {\n            handleAriaDescribedByAttribute(true);\n          }\n\n          instance.popperInstance.reference = target;\n          instance.setContent(tippyInstances[index].props.content);\n        }\n      };\n    }\n  };\n  return tippy(div(), _extends({}, optionalProps, {\n    plugins: [singleton].concat(plugins),\n    aria: null,\n    triggerTarget: references\n  }));\n};\n\nvar BUBBLING_EVENTS_MAP = {\n  mouseover: 'mouseenter',\n  focusin: 'focus',\n  click: 'click'\n};\n/**\n * Creates a delegate instance that controls the creation of tippy instances\n * for child elements (`target` CSS selector).\n */\n\nfunction delegate(targets, props,\n/** @deprecated use Props.plugins */\nplugins) {\n  if (plugins === void 0) {\n    plugins = [];\n  }\n\n  if (process.env.NODE_ENV !== \"production\") {\n    errorWhen(!(props && props.target), ['You must specity a `target` prop indicating a CSS selector string matching', 'the target elements that should receive a tippy.'].join(' '));\n  }\n\n  plugins = props.plugins || plugins;\n  var listeners = [];\n  var childTippyInstances = [];\n  var target = props.target;\n  var nativeProps = removeProperties(props, ['target']);\n\n  var parentProps = _extends({}, nativeProps, {\n    plugins: plugins,\n    trigger: 'manual'\n  });\n\n  var childProps = _extends({}, nativeProps, {\n    plugins: plugins,\n    showOnCreate: true\n  });\n\n  var returnValue = tippy(targets, parentProps);\n  var normalizedReturnValue = normalizeToArray(returnValue);\n\n  function onTrigger(event) {\n    if (!event.target) {\n      return;\n    }\n\n    var targetNode = event.target.closest(target);\n\n    if (!targetNode) {\n      return;\n    } // Get relevant trigger with fallbacks:\n    // 1. Check `data-tippy-trigger` attribute on target node\n    // 2. Fallback to `trigger` passed to `delegate()`\n    // 3. Fallback to `defaultProps.trigger`\n\n\n    var trigger = targetNode.getAttribute('data-tippy-trigger') || props.trigger || defaultProps.trigger; // Only create the instance if the bubbling event matches the trigger type\n\n    if (!includes(trigger, BUBBLING_EVENTS_MAP[event.type])) {\n      return;\n    }\n\n    var instance = tippy(targetNode, childProps);\n\n    if (instance) {\n      childTippyInstances = childTippyInstances.concat(instance);\n    }\n  }\n\n  function on(node, eventType, handler, options) {\n    if (options === void 0) {\n      options = false;\n    }\n\n    node.addEventListener(eventType, handler, options);\n    listeners.push({\n      node: node,\n      eventType: eventType,\n      handler: handler,\n      options: options\n    });\n  }\n\n  function addEventListeners(instance) {\n    var reference = instance.reference;\n    on(reference, 'mouseover', onTrigger);\n    on(reference, 'focusin', onTrigger);\n    on(reference, 'click', onTrigger);\n  }\n\n  function removeEventListeners() {\n    listeners.forEach(function (_ref) {\n      var node = _ref.node,\n          eventType = _ref.eventType,\n          handler = _ref.handler,\n          options = _ref.options;\n      node.removeEventListener(eventType, handler, options);\n    });\n    listeners = [];\n  }\n\n  function applyMutations(instance) {\n    var originalDestroy = instance.destroy;\n\n    instance.destroy = function (shouldDestroyChildInstances) {\n      if (shouldDestroyChildInstances === void 0) {\n        shouldDestroyChildInstances = true;\n      }\n\n      if (shouldDestroyChildInstances) {\n        childTippyInstances.forEach(function (instance) {\n          instance.destroy();\n        });\n      }\n\n      childTippyInstances = [];\n      removeEventListeners();\n      originalDestroy();\n    };\n\n    addEventListeners(instance);\n  }\n\n  normalizedReturnValue.forEach(applyMutations);\n  return returnValue;\n}\n\nvar animateFill = {\n  name: 'animateFill',\n  defaultValue: false,\n  fn: function fn(instance) {\n    var _instance$popperChild = instance.popperChildren,\n        tooltip = _instance$popperChild.tooltip,\n        content = _instance$popperChild.content;\n    var backdrop = instance.props.animateFill ? createBackdropElement() : null;\n\n    function addBackdropToPopperChildren() {\n      instance.popperChildren.backdrop = backdrop;\n    }\n\n    return {\n      onCreate: function onCreate() {\n        if (backdrop) {\n          addBackdropToPopperChildren();\n          tooltip.insertBefore(backdrop, tooltip.firstElementChild);\n          tooltip.setAttribute('data-animatefill', '');\n          tooltip.style.overflow = 'hidden';\n          instance.setProps({\n            animation: 'shift-away',\n            arrow: false\n          });\n        }\n      },\n      onMount: function onMount() {\n        if (backdrop) {\n          var transitionDuration = tooltip.style.transitionDuration;\n          var duration = Number(transitionDuration.replace('ms', '')); // The content should fade in after the backdrop has mostly filled the\n          // tooltip element. `clip-path` is the other alternative but is not\n          // well-supported and is buggy on some devices.\n\n          content.style.transitionDelay = Math.round(duration / 10) + \"ms\";\n          backdrop.style.transitionDuration = transitionDuration;\n          setVisibilityState([backdrop], 'visible'); // Warn if the stylesheets are not loaded\n\n          if (process.env.NODE_ENV !== \"production\") {\n            warnWhen(getComputedStyle(backdrop).position !== 'absolute', \"The `tippy.js/dist/backdrop.css` stylesheet has not been\\n              imported!\\n              \\n              The `animateFill` plugin requires this stylesheet to work.\");\n            warnWhen(getComputedStyle(tooltip).transform === 'none', \"The `tippy.js/animations/shift-away.css` stylesheet has not\\n              been imported!\\n              \\n              The `animateFill` plugin requires this stylesheet to work.\");\n          }\n        }\n      },\n      onShow: function onShow() {\n        if (backdrop) {\n          backdrop.style.transitionDuration = '0ms';\n        }\n      },\n      onHide: function onHide() {\n        if (backdrop) {\n          setVisibilityState([backdrop], 'hidden');\n        }\n      },\n      onAfterUpdate: function onAfterUpdate() {\n        // With this type of prop, it's highly unlikely it will be changed\n        // dynamically. We'll leave out the diff/update logic it to save bytes.\n        // `popperChildren` is assigned a new object onAfterUpdate\n        addBackdropToPopperChildren();\n      }\n    };\n  }\n};\n\nfunction createBackdropElement() {\n  var backdrop = div();\n  backdrop.className = BACKDROP_CLASS;\n  setVisibilityState([backdrop], 'hidden');\n  return backdrop;\n}\n\nvar followCursor = {\n  name: 'followCursor',\n  defaultValue: false,\n  fn: function fn(instance) {\n    var reference = instance.reference,\n        popper = instance.popper;\n    var originalReference = null; // Support iframe contexts\n    // Static check that assumes any of the `triggerTarget` or `reference`\n    // nodes will never change documents, even when they are updated\n\n    var doc = getOwnerDocument(instance.props.triggerTarget || reference); // Internal state\n\n    var lastMouseMoveEvent;\n    var mouseCoords = null;\n    var isInternallySettingControlledProp = false; // These are controlled by this plugin, so we need to store the user's\n    // original prop value\n\n    var userProps = instance.props;\n\n    function setUserProps(props) {\n      var keys = Object.keys(props);\n      keys.forEach(function (prop) {\n        userProps[prop] = useIfDefined(props[prop], userProps[prop]);\n      });\n    }\n\n    function getIsManual() {\n      return instance.props.trigger.trim() === 'manual';\n    }\n\n    function getIsEnabled() {\n      // #597\n      var isValidMouseEvent = getIsManual() ? true : // Check if a keyboard \"click\"\n      mouseCoords !== null && !(mouseCoords.clientX === 0 && mouseCoords.clientY === 0);\n      return instance.props.followCursor && isValidMouseEvent;\n    }\n\n    function getIsInitialBehavior() {\n      return currentInput.isTouch || instance.props.followCursor === 'initial' && instance.state.isVisible;\n    }\n\n    function resetReference() {\n      if (instance.popperInstance && originalReference) {\n        instance.popperInstance.reference = originalReference;\n      }\n    }\n\n    function handlePlacement() {\n      // Due to `getVirtualOffsets()`, we need to reverse the placement if it's\n      // shifted (start -> end, and vice-versa)\n      // Early bail-out\n      if (!getIsEnabled() && instance.props.placement === userProps.placement) {\n        return;\n      }\n\n      var placement = userProps.placement;\n      var shift = placement.split('-')[1];\n      isInternallySettingControlledProp = true;\n      instance.setProps({\n        placement: getIsEnabled() && shift ? placement.replace(shift, shift === 'start' ? 'end' : 'start') : placement\n      });\n      isInternallySettingControlledProp = false;\n    }\n\n    function handlePopperListeners() {\n      if (!instance.popperInstance) {\n        return;\n      } // Popper's scroll listeners make sense for `true` only. TODO: work out\n      // how to only listen horizontal scroll for \"horizontal\" and vertical\n      // scroll for \"vertical\"\n\n\n      if (getIsEnabled() && getIsInitialBehavior()) {\n        instance.popperInstance.disableEventListeners();\n      }\n    }\n\n    function handleMouseMoveListener() {\n      if (getIsEnabled()) {\n        addListener();\n      } else {\n        resetReference();\n      }\n    }\n\n    function triggerLastMouseMove() {\n      if (getIsEnabled()) {\n        onMouseMove(lastMouseMoveEvent);\n      }\n    }\n\n    function addListener() {\n      doc.addEventListener('mousemove', onMouseMove);\n    }\n\n    function removeListener() {\n      doc.removeEventListener('mousemove', onMouseMove);\n    }\n\n    function onMouseMove(event) {\n      var _lastMouseMoveEvent = lastMouseMoveEvent = event,\n          clientX = _lastMouseMoveEvent.clientX,\n          clientY = _lastMouseMoveEvent.clientY;\n\n      if (!instance.popperInstance || !instance.state.currentPlacement) {\n        return;\n      } // If the instance is interactive, avoid updating the position unless it's\n      // over the reference element\n\n\n      var isCursorOverReference = closestCallback(event.target, function (el) {\n        return el === reference;\n      });\n      var followCursor = instance.props.followCursor;\n      var isHorizontal = followCursor === 'horizontal';\n      var isVertical = followCursor === 'vertical';\n      var isVerticalPlacement = includes(['top', 'bottom'], getBasePlacement(instance.state.currentPlacement)); // The virtual reference needs some size to prevent itself from overflowing\n\n      var _getVirtualOffsets = getVirtualOffsets(popper, isVerticalPlacement),\n          size = _getVirtualOffsets.size,\n          x = _getVirtualOffsets.x,\n          y = _getVirtualOffsets.y;\n\n      if (isCursorOverReference || !instance.props.interactive) {\n        // Preserve custom position ReferenceObjects, which may not be the\n        // original targets reference passed as an argument\n        if (originalReference === null) {\n          originalReference = instance.popperInstance.reference;\n        }\n\n        instance.popperInstance.reference = {\n          referenceNode: reference,\n          // These `client` values don't get used by Popper.js if they are 0\n          clientWidth: 0,\n          clientHeight: 0,\n          getBoundingClientRect: function getBoundingClientRect() {\n            var rect = reference.getBoundingClientRect();\n            return {\n              width: isVerticalPlacement ? size : 0,\n              height: isVerticalPlacement ? 0 : size,\n              top: (isHorizontal ? rect.top : clientY) - y,\n              bottom: (isHorizontal ? rect.bottom : clientY) + y,\n              left: (isVertical ? rect.left : clientX) - x,\n              right: (isVertical ? rect.right : clientX) + x\n            };\n          }\n        };\n        instance.popperInstance.update();\n      }\n\n      if (getIsInitialBehavior()) {\n        removeListener();\n      }\n    }\n\n    return {\n      onAfterUpdate: function onAfterUpdate(_, partialProps) {\n        if (!isInternallySettingControlledProp) {\n          setUserProps(partialProps);\n\n          if (partialProps.placement) {\n            handlePlacement();\n          }\n        } // A new placement causes the popperInstance to be recreated\n\n\n        if (partialProps.placement) {\n          handlePopperListeners();\n        } // Wait for `.update()` to set `instance.state.currentPlacement` to\n        // the new placement\n\n\n        requestAnimationFrame(triggerLastMouseMove);\n      },\n      onMount: function onMount() {\n        triggerLastMouseMove();\n        handlePopperListeners();\n      },\n      onShow: function onShow() {\n        if (getIsManual()) {\n          // Since there's no trigger event to use, we have to use these as\n          // baseline coords\n          mouseCoords = {\n            clientX: 0,\n            clientY: 0\n          }; // Ensure `lastMouseMoveEvent` doesn't access any other properties\n          // of a MouseEvent here\n\n          lastMouseMoveEvent = mouseCoords;\n          handlePlacement();\n          handleMouseMoveListener();\n        }\n      },\n      onTrigger: function onTrigger(_, event) {\n        // Tapping on touch devices can trigger `mouseenter` then `focus`\n        if (mouseCoords) {\n          return;\n        }\n\n        if (isMouseEvent(event)) {\n          mouseCoords = {\n            clientX: event.clientX,\n            clientY: event.clientY\n          };\n          lastMouseMoveEvent = event;\n        }\n\n        handlePlacement();\n        handleMouseMoveListener();\n      },\n      onUntrigger: function onUntrigger() {\n        // If untriggered before showing (`onHidden` will never be invoked)\n        if (!instance.state.isVisible) {\n          removeListener();\n          mouseCoords = null;\n        }\n      },\n      onHidden: function onHidden() {\n        removeListener();\n        resetReference();\n        mouseCoords = null;\n      }\n    };\n  }\n};\n\nfunction getVirtualOffsets(popper, isVerticalPlacement) {\n  var size = isVerticalPlacement ? popper.offsetWidth : popper.offsetHeight;\n  return {\n    size: size,\n    x: isVerticalPlacement ? size : 0,\n    y: isVerticalPlacement ? 0 : size\n  };\n} // position. This will require the `followCursor` plugin's fixes for overflow\n// due to using event.clientX/Y values. (normalizedPlacement, getVirtualOffsets)\n\n\nvar inlinePositioning = {\n  name: 'inlinePositioning',\n  defaultValue: false,\n  fn: function fn(instance) {\n    var reference = instance.reference;\n\n    function getIsEnabled() {\n      return !!instance.props.inlinePositioning;\n    }\n\n    return {\n      onHidden: function onHidden() {\n        if (getIsEnabled()) {\n          instance.popperInstance.reference = reference;\n        }\n      },\n      onShow: function onShow() {\n        if (!getIsEnabled()) {\n          return;\n        }\n\n        instance.popperInstance.reference = {\n          referenceNode: reference,\n          // These `client` values don't get used by Popper.js if they are 0\n          clientWidth: 0,\n          clientHeight: 0,\n          getBoundingClientRect: function getBoundingClientRect() {\n            return getInlineBoundingClientRect(instance.state.currentPlacement && getBasePlacement(instance.state.currentPlacement), reference.getBoundingClientRect(), arrayFrom(reference.getClientRects()));\n          }\n        };\n      }\n    };\n  }\n};\n\nfunction getInlineBoundingClientRect(currentBasePlacement, boundingRect, clientRects) {\n  // Not an inline element, or placement is not yet known\n  if (clientRects.length < 2 || currentBasePlacement === null) {\n    return boundingRect;\n  }\n\n  switch (currentBasePlacement) {\n    case 'top':\n    case 'bottom':\n      {\n        var firstRect = clientRects[0];\n        var lastRect = clientRects[clientRects.length - 1];\n        var isTop = currentBasePlacement === 'top';\n        var top = firstRect.top;\n        var bottom = lastRect.bottom;\n        var left = isTop ? firstRect.left : lastRect.left;\n        var right = isTop ? firstRect.right : lastRect.right;\n        var width = right - left;\n        var height = bottom - top;\n        return {\n          top: top,\n          bottom: bottom,\n          left: left,\n          right: right,\n          width: width,\n          height: height\n        };\n      }\n\n    case 'left':\n    case 'right':\n      {\n        var minLeft = Math.min.apply(Math, clientRects.map(function (rects) {\n          return rects.left;\n        }));\n        var maxRight = Math.max.apply(Math, clientRects.map(function (rects) {\n          return rects.right;\n        }));\n        var measureRects = clientRects.filter(function (rect) {\n          return currentBasePlacement === 'left' ? rect.left === minLeft : rect.right === maxRight;\n        });\n        var _top = measureRects[0].top;\n        var _bottom = measureRects[measureRects.length - 1].bottom;\n        var _left = minLeft;\n        var _right = maxRight;\n\n        var _width = _right - _left;\n\n        var _height = _bottom - _top;\n\n        return {\n          top: _top,\n          bottom: _bottom,\n          left: _left,\n          right: _right,\n          width: _width,\n          height: _height\n        };\n      }\n\n    default:\n      {\n        return boundingRect;\n      }\n  }\n}\n\nvar sticky = {\n  name: 'sticky',\n  defaultValue: false,\n  fn: function fn(instance) {\n    var reference = instance.reference,\n        popper = instance.popper;\n\n    function getReference() {\n      return instance.popperInstance ? instance.popperInstance.reference : reference;\n    }\n\n    function shouldCheck(value) {\n      return instance.props.sticky === true || instance.props.sticky === value;\n    }\n\n    var prevRefRect = null;\n    var prevPopRect = null;\n\n    function updatePosition() {\n      var currentRefRect = shouldCheck('reference') ? getReference().getBoundingClientRect() : null;\n      var currentPopRect = shouldCheck('popper') ? popper.getBoundingClientRect() : null;\n\n      if (currentRefRect && areRectsDifferent(prevRefRect, currentRefRect) || currentPopRect && areRectsDifferent(prevPopRect, currentPopRect)) {\n        instance.popperInstance.update();\n      }\n\n      prevRefRect = currentRefRect;\n      prevPopRect = currentPopRect;\n\n      if (instance.state.isMounted) {\n        requestAnimationFrame(updatePosition);\n      }\n    }\n\n    return {\n      onMount: function onMount() {\n        if (instance.props.sticky) {\n          updatePosition();\n        }\n      }\n    };\n  }\n};\n\nfunction areRectsDifferent(rectA, rectB) {\n  if (rectA && rectB) {\n    return rectA.top !== rectB.top || rectA.right !== rectB.right || rectA.bottom !== rectB.bottom || rectA.left !== rectB.left;\n  }\n\n  return true;\n}\n\nexport { animateFill, createSingleton, delegate, followCursor, inlinePositioning, sticky };","map":{"version":3,"mappings":"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","names":["createSingleton","tippyInstances","optionalProps","plugins","errorWhen","Array","isArray","String","join","forEach","instance","disable","userAria","_extends","defaultProps","aria","currentAria","currentTarget","shouldSkipUpdate","references","map","reference","singleton","fn","handleAriaDescribedByAttribute","isShow","attr","props","interactive","setAttribute","popperChildren","tooltip","id","removeAttribute","onAfterUpdate","_","undefined","setProps","onDestroy","enable","onMount","onUntrigger","onTrigger","event","target","index","indexOf","state","isVisible","popperInstance","setContent","content","tippy","div","triggerTarget","BUBBLING_EVENTS_MAP","mouseover","focusin","click","delegate","targets","listeners","childTippyInstances","nativeProps","removeProperties","parentProps","trigger","childProps","showOnCreate","returnValue","normalizedReturnValue","normalizeToArray","targetNode","closest","getAttribute","includes","type","concat","on","node","eventType","handler","options","addEventListener","push","addEventListeners","removeEventListeners","removeEventListener","applyMutations","originalDestroy","destroy","shouldDestroyChildInstances","animateFill","name","defaultValue","backdrop","createBackdropElement","addBackdropToPopperChildren","onCreate","insertBefore","firstElementChild","style","overflow","animation","arrow","transitionDuration","duration","Number","replace","transitionDelay","Math","round","setVisibilityState","warnWhen","getComputedStyle","position","transform","onShow","onHide","className","BACKDROP_CLASS","followCursor","popper","originalReference","doc","getOwnerDocument","lastMouseMoveEvent","mouseCoords","isInternallySettingControlledProp","userProps","setUserProps","keys","Object","prop","useIfDefined","getIsManual","trim","getIsEnabled","isValidMouseEvent","clientX","clientY","getIsInitialBehavior","currentInput","isTouch","resetReference","handlePlacement","placement","shift","split","handlePopperListeners","disableEventListeners","handleMouseMoveListener","addListener","triggerLastMouseMove","onMouseMove","removeListener","currentPlacement","isCursorOverReference","closestCallback","el","isHorizontal","isVertical","isVerticalPlacement","getBasePlacement","getVirtualOffsets","size","x","y","referenceNode","clientWidth","clientHeight","getBoundingClientRect","rect","width","height","top","bottom","left","right","update","partialProps","requestAnimationFrame","isMouseEvent","onHidden","offsetWidth","offsetHeight","inlinePositioning","getInlineBoundingClientRect","arrayFrom","getClientRects","currentBasePlacement","boundingRect","clientRects","length","firstRect","lastRect","isTop","minLeft","min","rects","maxRight","max","measureRects","filter","sticky","getReference","shouldCheck","value","prevRefRect","prevPopRect","updatePosition","currentRefRect","currentPopRect","areRectsDifferent","isMounted","rectA","rectB"],"sources":["C:\\Users\\elijr\\Desktop\\CODING\\Personal Projects\\Portfolio\\eco\\frontend\\node_modules\\tippy.js\\src\\addons\\createSingleton.ts","C:\\Users\\elijr\\Desktop\\CODING\\Personal Projects\\Portfolio\\eco\\frontend\\node_modules\\tippy.js\\src\\addons\\delegate.ts","C:\\Users\\elijr\\Desktop\\CODING\\Personal Projects\\Portfolio\\eco\\frontend\\node_modules\\tippy.js\\src\\plugins\\animateFill.ts","C:\\Users\\elijr\\Desktop\\CODING\\Personal Projects\\Portfolio\\eco\\frontend\\node_modules\\tippy.js\\src\\plugins\\followCursor.ts","C:\\Users\\elijr\\Desktop\\CODING\\Personal Projects\\Portfolio\\eco\\frontend\\node_modules\\tippy.js\\src\\plugins\\inlinePositioning.ts","C:\\Users\\elijr\\Desktop\\CODING\\Personal Projects\\Portfolio\\eco\\frontend\\node_modules\\tippy.js\\src\\plugins\\sticky.ts"],"sourcesContent":["import {Instance, CreateSingleton, Plugin} from '../types';\nimport tippy from '..';\nimport {defaultProps} from '../props';\nimport {errorWhen} from '../validation';\nimport {div} from '../utils';\n\n/**\n * Re-uses a single tippy element for many different tippy instances.\n * Replaces v4's `tippy.group()`.\n */\nconst createSingleton: CreateSingleton = (\n  tippyInstances,\n  optionalProps = {},\n  /** @deprecated use Props.plugins */\n  plugins = [],\n) => {\n  if (__DEV__) {\n    errorWhen(\n      !Array.isArray(tippyInstances),\n      [\n        'The first argument passed to createSingleton() must be an array of tippy',\n        'instances. The passed value was',\n        String(tippyInstances),\n      ].join(' '),\n    );\n  }\n\n  plugins = optionalProps.plugins || plugins;\n\n  tippyInstances.forEach(instance => {\n    instance.disable();\n  });\n\n  let userAria = {...defaultProps, ...optionalProps}.aria;\n  let currentAria: string | null | undefined;\n  let currentTarget: Element;\n  let shouldSkipUpdate = false;\n\n  const references = tippyInstances.map(instance => instance.reference);\n\n  const singleton: Plugin = {\n    fn(instance) {\n      function handleAriaDescribedByAttribute(isShow: boolean): void {\n        if (!currentAria) {\n          return;\n        }\n\n        const attr = `aria-${currentAria}`;\n\n        if (isShow && !instance.props.interactive) {\n          currentTarget.setAttribute(attr, instance.popperChildren.tooltip.id);\n        } else {\n          currentTarget.removeAttribute(attr);\n        }\n      }\n\n      return {\n        onAfterUpdate(_, {aria}): void {\n          // Ensure `aria` for the singleton instance stays `null`, while\n          // changing the `userAria` value\n          if (aria !== undefined && aria !== userAria) {\n            if (!shouldSkipUpdate) {\n              userAria = aria;\n            } else {\n              shouldSkipUpdate = true;\n              instance.setProps({aria: null});\n              shouldSkipUpdate = false;\n            }\n          }\n        },\n        onDestroy(): void {\n          tippyInstances.forEach(instance => {\n            instance.enable();\n          });\n        },\n        onMount(): void {\n          handleAriaDescribedByAttribute(true);\n        },\n        onUntrigger(): void {\n          handleAriaDescribedByAttribute(false);\n        },\n        onTrigger(_, event): void {\n          const target = event.currentTarget as Element;\n          const index = references.indexOf(target);\n\n          // bail-out\n          if (target === currentTarget) {\n            return;\n          }\n\n          currentTarget = target;\n          currentAria = userAria;\n\n          if (instance.state.isVisible) {\n            handleAriaDescribedByAttribute(true);\n          }\n\n          instance.popperInstance!.reference = target;\n\n          instance.setContent(tippyInstances[index].props.content);\n        },\n      };\n    },\n  };\n\n  return tippy(div(), {\n    ...optionalProps,\n    plugins: [singleton, ...plugins],\n    aria: null,\n    triggerTarget: references,\n  }) as Instance;\n};\n\nexport default createSingleton;\n","import {Instance, Targets, Plugin, Props} from '../types';\nimport tippy from '..';\nimport {errorWhen} from '../validation';\nimport {removeProperties, normalizeToArray, includes} from '../utils';\nimport {defaultProps} from '../props';\nimport {ListenerObject} from '../types-internal';\n\nconst BUBBLING_EVENTS_MAP = {\n  mouseover: 'mouseenter',\n  focusin: 'focus',\n  click: 'click',\n};\n\n/**\n * Creates a delegate instance that controls the creation of tippy instances\n * for child elements (`target` CSS selector).\n */\nfunction delegate(\n  targets: Targets,\n  props: Partial<Props> & {target: string},\n  /** @deprecated use Props.plugins */\n  plugins: Plugin[] = [],\n): Instance | Instance[] {\n  if (__DEV__) {\n    errorWhen(\n      !(props && props.target),\n      [\n        'You must specity a `target` prop indicating a CSS selector string matching',\n        'the target elements that should receive a tippy.',\n      ].join(' '),\n    );\n  }\n\n  plugins = props.plugins || plugins;\n\n  let listeners: ListenerObject[] = [];\n  let childTippyInstances: Instance[] = [];\n\n  const {target} = props;\n\n  const nativeProps = removeProperties(props, ['target']);\n  const parentProps = {...nativeProps, plugins, trigger: 'manual'};\n  const childProps = {...nativeProps, plugins, showOnCreate: true};\n\n  const returnValue = tippy(targets, parentProps);\n  const normalizedReturnValue = normalizeToArray(returnValue);\n\n  function onTrigger(event: Event): void {\n    if (!event.target) {\n      return;\n    }\n\n    const targetNode = (event.target as Element).closest(target);\n\n    if (!targetNode) {\n      return;\n    }\n\n    // Get relevant trigger with fallbacks:\n    // 1. Check `data-tippy-trigger` attribute on target node\n    // 2. Fallback to `trigger` passed to `delegate()`\n    // 3. Fallback to `defaultProps.trigger`\n    const trigger =\n      targetNode.getAttribute('data-tippy-trigger') ||\n      props.trigger ||\n      defaultProps.trigger;\n\n    // Only create the instance if the bubbling event matches the trigger type\n    if (!includes(trigger, (BUBBLING_EVENTS_MAP as any)[event.type])) {\n      return;\n    }\n\n    const instance = tippy(targetNode, childProps);\n\n    if (instance) {\n      childTippyInstances = childTippyInstances.concat(instance);\n    }\n  }\n\n  function on(\n    node: Element,\n    eventType: string,\n    handler: EventListener,\n    options: object | boolean = false,\n  ): void {\n    node.addEventListener(eventType, handler, options);\n    listeners.push({node, eventType, handler, options});\n  }\n\n  function addEventListeners(instance: Instance): void {\n    const {reference} = instance;\n\n    on(reference, 'mouseover', onTrigger);\n    on(reference, 'focusin', onTrigger);\n    on(reference, 'click', onTrigger);\n  }\n\n  function removeEventListeners(): void {\n    listeners.forEach(({node, eventType, handler, options}: ListenerObject) => {\n      node.removeEventListener(eventType, handler, options);\n    });\n    listeners = [];\n  }\n\n  function applyMutations(instance: Instance): void {\n    const originalDestroy = instance.destroy;\n    instance.destroy = (shouldDestroyChildInstances = true): void => {\n      if (shouldDestroyChildInstances) {\n        childTippyInstances.forEach(instance => {\n          instance.destroy();\n        });\n      }\n\n      childTippyInstances = [];\n\n      removeEventListeners();\n      originalDestroy();\n    };\n\n    addEventListeners(instance);\n  }\n\n  normalizedReturnValue.forEach(applyMutations);\n\n  return returnValue;\n}\n\nexport default delegate;\n","import {AnimateFill} from '../types';\nimport {BACKDROP_CLASS} from '../constants';\nimport {div, setVisibilityState} from '../utils';\nimport {warnWhen} from '../validation';\n\nconst animateFill: AnimateFill = {\n  name: 'animateFill',\n  defaultValue: false,\n  fn(instance) {\n    const {tooltip, content} = instance.popperChildren;\n\n    const backdrop = instance.props.animateFill\n      ? createBackdropElement()\n      : null;\n\n    function addBackdropToPopperChildren(): void {\n      instance.popperChildren.backdrop = backdrop;\n    }\n\n    return {\n      onCreate(): void {\n        if (backdrop) {\n          addBackdropToPopperChildren();\n\n          tooltip.insertBefore(backdrop, tooltip.firstElementChild!);\n          tooltip.setAttribute('data-animatefill', '');\n          tooltip.style.overflow = 'hidden';\n\n          instance.setProps({animation: 'shift-away', arrow: false});\n        }\n      },\n      onMount(): void {\n        if (backdrop) {\n          const {transitionDuration} = tooltip.style;\n          const duration = Number(transitionDuration.replace('ms', ''));\n\n          // The content should fade in after the backdrop has mostly filled the\n          // tooltip element. `clip-path` is the other alternative but is not\n          // well-supported and is buggy on some devices.\n          content.style.transitionDelay = `${Math.round(duration / 10)}ms`;\n\n          backdrop.style.transitionDuration = transitionDuration;\n          setVisibilityState([backdrop], 'visible');\n\n          // Warn if the stylesheets are not loaded\n          if (__DEV__) {\n            warnWhen(\n              getComputedStyle(backdrop).position !== 'absolute',\n              `The \\`tippy.js/dist/backdrop.css\\` stylesheet has not been\n              imported!\n              \n              The \\`animateFill\\` plugin requires this stylesheet to work.`,\n            );\n\n            warnWhen(\n              getComputedStyle(tooltip).transform === 'none',\n              `The \\`tippy.js/animations/shift-away.css\\` stylesheet has not\n              been imported!\n              \n              The \\`animateFill\\` plugin requires this stylesheet to work.`,\n            );\n          }\n        }\n      },\n      onShow(): void {\n        if (backdrop) {\n          backdrop.style.transitionDuration = '0ms';\n        }\n      },\n      onHide(): void {\n        if (backdrop) {\n          setVisibilityState([backdrop], 'hidden');\n        }\n      },\n      onAfterUpdate(): void {\n        // With this type of prop, it's highly unlikely it will be changed\n        // dynamically. We'll leave out the diff/update logic it to save bytes.\n\n        // `popperChildren` is assigned a new object onAfterUpdate\n        addBackdropToPopperChildren();\n      },\n    };\n  },\n};\n\nexport default animateFill;\n\nfunction createBackdropElement(): HTMLDivElement {\n  const backdrop = div();\n  backdrop.className = BACKDROP_CLASS;\n  setVisibilityState([backdrop], 'hidden');\n  return backdrop;\n}\n","import {\n  PopperElement,\n  Placement,\n  FollowCursor,\n  Props,\n  ReferenceElement,\n} from '../types';\nimport {\n  includes,\n  closestCallback,\n  useIfDefined,\n  isMouseEvent,\n  getOwnerDocument,\n} from '../utils';\nimport {getBasePlacement} from '../popper';\nimport {currentInput} from '../bindGlobalEventListeners';\nimport Popper from 'popper.js';\n\nconst followCursor: FollowCursor = {\n  name: 'followCursor',\n  defaultValue: false,\n  fn(instance) {\n    const {reference, popper} = instance;\n\n    let originalReference:\n      | ReferenceElement\n      | Popper.ReferenceObject\n      | null = null;\n\n    // Support iframe contexts\n    // Static check that assumes any of the `triggerTarget` or `reference`\n    // nodes will never change documents, even when they are updated\n    const doc = getOwnerDocument(instance.props.triggerTarget || reference);\n\n    // Internal state\n    let lastMouseMoveEvent: MouseEvent;\n    let mouseCoords: {clientX: number; clientY: number} | null = null;\n    let isInternallySettingControlledProp = false;\n\n    // These are controlled by this plugin, so we need to store the user's\n    // original prop value\n    const userProps = instance.props;\n\n    function setUserProps(props: Partial<Props>): void {\n      const keys = Object.keys(props) as Array<keyof Props>;\n      keys.forEach(prop => {\n        (userProps as any)[prop] = useIfDefined(props[prop], userProps[prop]);\n      });\n    }\n\n    function getIsManual(): boolean {\n      return instance.props.trigger.trim() === 'manual';\n    }\n\n    function getIsEnabled(): boolean {\n      // #597\n      const isValidMouseEvent = getIsManual()\n        ? true\n        : // Check if a keyboard \"click\"\n          mouseCoords !== null &&\n          !(mouseCoords.clientX === 0 && mouseCoords.clientY === 0);\n\n      return instance.props.followCursor && isValidMouseEvent;\n    }\n\n    function getIsInitialBehavior(): boolean {\n      return (\n        currentInput.isTouch ||\n        (instance.props.followCursor === 'initial' && instance.state.isVisible)\n      );\n    }\n\n    function resetReference(): void {\n      if (instance.popperInstance && originalReference) {\n        instance.popperInstance.reference = originalReference;\n      }\n    }\n\n    function handlePlacement(): void {\n      // Due to `getVirtualOffsets()`, we need to reverse the placement if it's\n      // shifted (start -> end, and vice-versa)\n\n      // Early bail-out\n      if (!getIsEnabled() && instance.props.placement === userProps.placement) {\n        return;\n      }\n\n      const {placement} = userProps;\n      const shift = placement.split('-')[1];\n\n      isInternallySettingControlledProp = true;\n\n      instance.setProps({\n        placement: (getIsEnabled() && shift\n          ? placement.replace(shift, shift === 'start' ? 'end' : 'start')\n          : placement) as Placement,\n      });\n\n      isInternallySettingControlledProp = false;\n    }\n\n    function handlePopperListeners(): void {\n      if (!instance.popperInstance) {\n        return;\n      }\n\n      // Popper's scroll listeners make sense for `true` only. TODO: work out\n      // how to only listen horizontal scroll for \"horizontal\" and vertical\n      // scroll for \"vertical\"\n      if (getIsEnabled() && getIsInitialBehavior()) {\n        instance.popperInstance.disableEventListeners();\n      }\n    }\n\n    function handleMouseMoveListener(): void {\n      if (getIsEnabled()) {\n        addListener();\n      } else {\n        resetReference();\n      }\n    }\n\n    function triggerLastMouseMove(): void {\n      if (getIsEnabled()) {\n        onMouseMove(lastMouseMoveEvent);\n      }\n    }\n\n    function addListener(): void {\n      doc.addEventListener('mousemove', onMouseMove);\n    }\n\n    function removeListener(): void {\n      doc.removeEventListener('mousemove', onMouseMove);\n    }\n\n    function onMouseMove(event: MouseEvent): void {\n      const {clientX, clientY} = (lastMouseMoveEvent = event);\n\n      if (!instance.popperInstance || !instance.state.currentPlacement) {\n        return;\n      }\n\n      // If the instance is interactive, avoid updating the position unless it's\n      // over the reference element\n      const isCursorOverReference = closestCallback(\n        event.target as Element,\n        (el: Element) => el === reference,\n      );\n\n      const {followCursor} = instance.props;\n      const isHorizontal = followCursor === 'horizontal';\n      const isVertical = followCursor === 'vertical';\n      const isVerticalPlacement = includes(\n        ['top', 'bottom'],\n        getBasePlacement(instance.state.currentPlacement),\n      );\n\n      // The virtual reference needs some size to prevent itself from overflowing\n      const {size, x, y} = getVirtualOffsets(popper, isVerticalPlacement);\n\n      if (isCursorOverReference || !instance.props.interactive) {\n        // Preserve custom position ReferenceObjects, which may not be the\n        // original targets reference passed as an argument\n        if (originalReference === null) {\n          originalReference = instance.popperInstance.reference;\n        }\n\n        instance.popperInstance.reference = {\n          referenceNode: reference,\n          // These `client` values don't get used by Popper.js if they are 0\n          clientWidth: 0,\n          clientHeight: 0,\n          getBoundingClientRect(): DOMRect | ClientRect {\n            const rect = reference.getBoundingClientRect();\n            return {\n              width: isVerticalPlacement ? size : 0,\n              height: isVerticalPlacement ? 0 : size,\n              top: (isHorizontal ? rect.top : clientY) - y,\n              bottom: (isHorizontal ? rect.bottom : clientY) + y,\n              left: (isVertical ? rect.left : clientX) - x,\n              right: (isVertical ? rect.right : clientX) + x,\n            };\n          },\n        };\n\n        instance.popperInstance.update();\n      }\n\n      if (getIsInitialBehavior()) {\n        removeListener();\n      }\n    }\n\n    return {\n      onAfterUpdate(_, partialProps): void {\n        if (!isInternallySettingControlledProp) {\n          setUserProps(partialProps);\n\n          if (partialProps.placement) {\n            handlePlacement();\n          }\n        }\n\n        // A new placement causes the popperInstance to be recreated\n        if (partialProps.placement) {\n          handlePopperListeners();\n        }\n\n        // Wait for `.update()` to set `instance.state.currentPlacement` to\n        // the new placement\n        requestAnimationFrame(triggerLastMouseMove);\n      },\n      onMount(): void {\n        triggerLastMouseMove();\n        handlePopperListeners();\n      },\n      onShow(): void {\n        if (getIsManual()) {\n          // Since there's no trigger event to use, we have to use these as\n          // baseline coords\n          mouseCoords = {clientX: 0, clientY: 0};\n          // Ensure `lastMouseMoveEvent` doesn't access any other properties\n          // of a MouseEvent here\n          lastMouseMoveEvent = mouseCoords as MouseEvent;\n\n          handlePlacement();\n          handleMouseMoveListener();\n        }\n      },\n      onTrigger(_, event): void {\n        // Tapping on touch devices can trigger `mouseenter` then `focus`\n        if (mouseCoords) {\n          return;\n        }\n\n        if (isMouseEvent(event)) {\n          mouseCoords = {clientX: event.clientX, clientY: event.clientY};\n          lastMouseMoveEvent = event;\n        }\n\n        handlePlacement();\n        handleMouseMoveListener();\n      },\n      onUntrigger(): void {\n        // If untriggered before showing (`onHidden` will never be invoked)\n        if (!instance.state.isVisible) {\n          removeListener();\n          mouseCoords = null;\n        }\n      },\n      onHidden(): void {\n        removeListener();\n        resetReference();\n        mouseCoords = null;\n      },\n    };\n  },\n};\n\nexport default followCursor;\n\nexport function getVirtualOffsets(\n  popper: PopperElement,\n  isVerticalPlacement: boolean,\n): {\n  size: number;\n  x: number;\n  y: number;\n} {\n  const size = isVerticalPlacement ? popper.offsetWidth : popper.offsetHeight;\n\n  return {\n    size,\n    x: isVerticalPlacement ? size : 0,\n    y: isVerticalPlacement ? 0 : size,\n  };\n}\n","import {InlinePositioning, BasePlacement} from '../types';\nimport {arrayFrom} from '../utils';\nimport {getBasePlacement} from '../popper';\n\n// TODO: Work on a \"cursor\" value so it chooses a rect optimal to the cursor\n// position. This will require the `followCursor` plugin's fixes for overflow\n// due to using event.clientX/Y values. (normalizedPlacement, getVirtualOffsets)\nconst inlinePositioning: InlinePositioning = {\n  name: 'inlinePositioning',\n  defaultValue: false,\n  fn(instance) {\n    const {reference} = instance;\n\n    function getIsEnabled(): boolean {\n      return !!instance.props.inlinePositioning;\n    }\n\n    return {\n      onHidden(): void {\n        if (getIsEnabled()) {\n          instance.popperInstance!.reference = reference;\n        }\n      },\n      onShow(): void {\n        if (!getIsEnabled()) {\n          return;\n        }\n\n        instance.popperInstance!.reference = {\n          referenceNode: reference,\n          // These `client` values don't get used by Popper.js if they are 0\n          clientWidth: 0,\n          clientHeight: 0,\n          getBoundingClientRect(): ClientRect | DOMRect {\n            return getInlineBoundingClientRect(\n              instance.state.currentPlacement &&\n                getBasePlacement(instance.state.currentPlacement),\n              reference.getBoundingClientRect(),\n              arrayFrom(reference.getClientRects()),\n            );\n          },\n        };\n      },\n    };\n  },\n};\n\nexport default inlinePositioning;\n\nexport function getInlineBoundingClientRect(\n  currentBasePlacement: BasePlacement | null,\n  boundingRect: ClientRect,\n  clientRects: ClientRect[],\n): ClientRect {\n  // Not an inline element, or placement is not yet known\n  if (clientRects.length < 2 || currentBasePlacement === null) {\n    return boundingRect;\n  }\n\n  switch (currentBasePlacement) {\n    case 'top':\n    case 'bottom': {\n      const firstRect = clientRects[0];\n      const lastRect = clientRects[clientRects.length - 1];\n      const isTop = currentBasePlacement === 'top';\n\n      const top = firstRect.top;\n      const bottom = lastRect.bottom;\n      const left = isTop ? firstRect.left : lastRect.left;\n      const right = isTop ? firstRect.right : lastRect.right;\n      const width = right - left;\n      const height = bottom - top;\n\n      return {top, bottom, left, right, width, height};\n    }\n    case 'left':\n    case 'right': {\n      const minLeft = Math.min(...clientRects.map(rects => rects.left));\n      const maxRight = Math.max(...clientRects.map(rects => rects.right));\n      const measureRects = clientRects.filter(rect =>\n        currentBasePlacement === 'left'\n          ? rect.left === minLeft\n          : rect.right === maxRight,\n      );\n\n      const top = measureRects[0].top;\n      const bottom = measureRects[measureRects.length - 1].bottom;\n      const left = minLeft;\n      const right = maxRight;\n      const width = right - left;\n      const height = bottom - top;\n\n      return {top, bottom, left, right, width, height};\n    }\n    default: {\n      return boundingRect;\n    }\n  }\n}\n","import {Sticky, ReferenceElement} from '../types';\nimport Popper from 'popper.js';\n\nconst sticky: Sticky = {\n  name: 'sticky',\n  defaultValue: false,\n  fn(instance) {\n    const {reference, popper} = instance;\n\n    function getReference(): ReferenceElement | Popper.ReferenceObject {\n      return instance.popperInstance\n        ? instance.popperInstance.reference\n        : reference;\n    }\n\n    function shouldCheck(value: 'reference' | 'popper'): boolean {\n      return instance.props.sticky === true || instance.props.sticky === value;\n    }\n\n    let prevRefRect: ClientRect | null = null;\n    let prevPopRect: ClientRect | null = null;\n\n    function updatePosition(): void {\n      const currentRefRect = shouldCheck('reference')\n        ? getReference().getBoundingClientRect()\n        : null;\n      const currentPopRect = shouldCheck('popper')\n        ? popper.getBoundingClientRect()\n        : null;\n\n      if (\n        (currentRefRect && areRectsDifferent(prevRefRect, currentRefRect)) ||\n        (currentPopRect && areRectsDifferent(prevPopRect, currentPopRect))\n      ) {\n        instance.popperInstance!.update();\n      }\n\n      prevRefRect = currentRefRect;\n      prevPopRect = currentPopRect;\n\n      if (instance.state.isMounted) {\n        requestAnimationFrame(updatePosition);\n      }\n    }\n\n    return {\n      onMount(): void {\n        if (instance.props.sticky) {\n          updatePosition();\n        }\n      },\n    };\n  },\n};\n\nexport default sticky;\n\nfunction areRectsDifferent(\n  rectA: ClientRect | null,\n  rectB: ClientRect | null,\n): boolean {\n  if (rectA && rectB) {\n    return (\n      rectA.top !== rectB.top ||\n      rectA.right !== rectB.right ||\n      rectA.bottom !== rectB.bottom ||\n      rectA.left !== rectB.left\n    );\n  }\n\n  return true;\n}\n"]},"metadata":{},"sourceType":"module"}