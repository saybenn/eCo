{"ast":null,"code":"function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n} // Bundled with Packemon: https://packemon.dev\n// Platform: browser, Support: stable, Format: esm\n\n\nimport { F as Filter, A as ALLOWED_TAG_LIST, B as BANNED_TAG_LIST, a as ATTRIBUTES, b as FILTER_DENY, c as ATTRIBUTES_TO_PROPS, T as TAGS, E as Element, d as FILTER_CAST_BOOL, e as FILTER_CAST_NUMBER, f as FILTER_NO_CAST } from './bundle-94421b73.js';\nexport { A as ALLOWED_TAG_LIST, a as ATTRIBUTES, c as ATTRIBUTES_TO_PROPS, B as BANNED_TAG_LIST, E as Element, n as FILTER_ALLOW, d as FILTER_CAST_BOOL, e as FILTER_CAST_NUMBER, b as FILTER_DENY, f as FILTER_NO_CAST, F as Filter, M as Matcher, T as TAGS, k as TYPE_EMBEDDED, g as TYPE_FLOW, i as TYPE_HEADING, l as TYPE_INTERACTIVE, m as TYPE_PALPABLE, j as TYPE_PHRASING, h as TYPE_SECTION, o as match } from './bundle-94421b73.js';\nimport React from 'react';\nimport escapeHtml from 'escape-html';\nconst INVALID_STYLES = /(url|image|image-set)\\(/i;\n\nclass StyleFilter extends Filter {\n  attribute(name, value) {\n    if (name === 'style') {\n      Object.keys(value).forEach(key => {\n        if (String(value[key]).match(INVALID_STYLES)) {\n          // eslint-disable-next-line no-param-reassign\n          delete value[key];\n        }\n      });\n    } // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n\n\n    return value;\n  }\n\n}\n/* eslint-disable no-bitwise, no-cond-assign, complexity, @typescript-eslint/no-unsafe-return */\n\n\nconst ELEMENT_NODE = 1;\nconst TEXT_NODE = 3;\nconst INVALID_ROOTS = /^<(!doctype|(html|head|body)(\\s|>))/i;\nconst ALLOWED_ATTRS = /^(aria-|data-|\\w+:)/iu;\nconst OPEN_TOKEN = /{{{(\\w+)\\/?}}}/;\n\nfunction createDocument() {\n  // Maybe SSR? Just do nothing instead of crashing!\n  if (typeof window === 'undefined' || typeof document === 'undefined') {\n    return undefined;\n  }\n\n  return document.implementation.createHTMLDocument('Interweave');\n}\n\nclass Parser {\n  constructor(markup) {\n    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let matchers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    let filters = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n\n    var _props$allowList;\n\n    _defineProperty(this, \"allowed\", void 0);\n\n    _defineProperty(this, \"banned\", void 0);\n\n    _defineProperty(this, \"blocked\", void 0);\n\n    _defineProperty(this, \"container\", void 0);\n\n    _defineProperty(this, \"content\", []);\n\n    _defineProperty(this, \"props\", void 0);\n\n    _defineProperty(this, \"matchers\", void 0);\n\n    _defineProperty(this, \"filters\", void 0);\n\n    _defineProperty(this, \"keyIndex\", void 0);\n\n    if (process.env.NODE_ENV !== \"production\" && markup && typeof markup !== 'string') {\n      throw new TypeError('Interweave parser requires a valid string.');\n    }\n\n    this.props = props;\n    this.matchers = matchers;\n    this.filters = [...filters, new StyleFilter()];\n    this.keyIndex = -1;\n    this.container = this.createContainer(markup || '');\n    this.allowed = new Set((_props$allowList = props.allowList) !== null && _props$allowList !== void 0 ? _props$allowList : ALLOWED_TAG_LIST);\n    this.banned = new Set(BANNED_TAG_LIST);\n    this.blocked = new Set(props.blockList);\n  }\n  /**\n   * Loop through and apply all registered attribute filters.\n   */\n\n\n  applyAttributeFilters(name, value) {\n    return this.filters.reduce((nextValue, filter) => nextValue !== null && typeof filter.attribute === 'function' ? filter.attribute(name, nextValue) : nextValue, value);\n  }\n  /**\n   * Loop through and apply all registered node filters.\n   */\n\n\n  applyNodeFilters(name, node) {\n    // Allow null to be returned\n    return this.filters.reduce((nextNode, filter) => nextNode !== null && typeof filter.node === 'function' ? filter.node(name, nextNode) : nextNode, node);\n  }\n  /**\n   * Loop through and apply all registered matchers to the string.\n   * If a match is found, create a React element, and build a new array.\n   * This array allows React to interpolate and render accordingly.\n   */\n\n\n  applyMatchers(string, parentConfig) {\n    const elements = {};\n    const {\n      props\n    } = this;\n    let matchedString = string;\n    let elementIndex = 0;\n    let parts = null;\n    this.matchers.forEach(matcher => {\n      const tagName = matcher.asTag().toLowerCase();\n      const config = this.getTagConfig(tagName); // Skip matchers that have been disabled from props or are not supported\n\n      if (props[matcher.inverseName] || !this.isTagAllowed(tagName)) {\n        return;\n      } // Skip matchers in which the child cannot be rendered\n\n\n      if (!this.canRenderChild(parentConfig, config)) {\n        return;\n      } // Continuously trigger the matcher until no matches are found\n\n\n      let tokenizedString = '';\n\n      while (matchedString && (parts = matcher.match(matchedString))) {\n        const {\n          index,\n          length,\n          match,\n          valid,\n          void: isVoid,\n          ...partProps\n        } = parts;\n        const tokenName = matcher.propName + String(elementIndex); // Piece together a new string with interpolated tokens\n\n        if (index > 0) {\n          tokenizedString += matchedString.slice(0, index);\n        }\n\n        if (valid) {\n          tokenizedString += isVoid ? `{{{${tokenName}/}}}` : `{{{${tokenName}}}}${match}{{{/${tokenName}}}}`;\n          this.keyIndex += 1;\n          elementIndex += 1;\n          elements[tokenName] = {\n            children: match,\n            matcher,\n            props: { ...props,\n              ...partProps,\n              key: this.keyIndex\n            }\n          };\n        } else {\n          tokenizedString += match;\n        } // Reduce the string being matched against,\n        // otherwise we end up in an infinite loop!\n\n\n        if (matcher.greedy) {\n          matchedString = tokenizedString + matchedString.slice(index + length);\n          tokenizedString = '';\n        } else {\n          // eslint-disable-next-line unicorn/explicit-length-check\n          matchedString = matchedString.slice(index + (length || match.length));\n        }\n      } // Update the matched string with the tokenized string,\n      // so that the next matcher can apply to it.\n\n\n      if (!matcher.greedy) {\n        matchedString = tokenizedString + matchedString;\n      }\n    });\n\n    if (elementIndex === 0) {\n      return string;\n    }\n\n    return this.replaceTokens(matchedString, elements);\n  }\n  /**\n   * Determine whether the child can be rendered within the parent.\n   */\n\n\n  canRenderChild(parentConfig, childConfig) {\n    if (!parentConfig.tagName || !childConfig.tagName) {\n      return false;\n    } // No children\n\n\n    if (parentConfig.void) {\n      return false;\n    } // Valid children\n\n\n    if (parentConfig.children.length > 0) {\n      return parentConfig.children.includes(childConfig.tagName);\n    }\n\n    if (parentConfig.invalid.length > 0 && parentConfig.invalid.includes(childConfig.tagName)) {\n      return false;\n    } // Valid parent\n\n\n    if (childConfig.parent.length > 0) {\n      return childConfig.parent.includes(parentConfig.tagName);\n    } // Self nesting\n\n\n    if (!parentConfig.self && parentConfig.tagName === childConfig.tagName) {\n      return false;\n    } // Content category type\n\n\n    return Boolean(parentConfig && parentConfig.content & childConfig.type);\n  }\n  /**\n   * Convert line breaks in a string to HTML `<br/>` tags.\n   * If the string contains HTML, we should not convert anything,\n   * as line breaks should be handled by `<br/>`s in the markup itself.\n   */\n\n\n  convertLineBreaks(markup) {\n    const {\n      noHtml,\n      disableLineBreaks\n    } = this.props;\n\n    if (noHtml || disableLineBreaks || markup.match(/<((?:\\/[ a-z]+)|(?:[ a-z]+\\/))>/gi)) {\n      return markup;\n    } // Replace carriage returns\n\n\n    let nextMarkup = markup.replace(/\\r\\n/g, '\\n'); // Replace long line feeds\n\n    nextMarkup = nextMarkup.replace(/\\n{3,}/g, '\\n\\n\\n'); // Replace line feeds with `<br/>`s\n\n    nextMarkup = nextMarkup.replace(/\\n/g, '<br/>');\n    return nextMarkup;\n  }\n  /**\n   * Create a detached HTML document that allows for easy HTML\n   * parsing while not triggering scripts or loading external\n   * resources.\n   */\n\n\n  createContainer(markup) {\n    var _this$props$container;\n\n    const factory = typeof global !== 'undefined' && global.INTERWEAVE_SSR_POLYFILL || createDocument;\n    const doc = factory();\n\n    if (!doc) {\n      return undefined;\n    }\n\n    const tag = (_this$props$container = this.props.containerTagName) !== null && _this$props$container !== void 0 ? _this$props$container : 'body';\n    const el = tag === 'body' || tag === 'fragment' ? doc.body : doc.createElement(tag);\n\n    if (markup.match(INVALID_ROOTS)) {\n      if (process.env.NODE_ENV !== \"production\") {\n        throw new Error('HTML documents as Interweave content are not supported.');\n      }\n    } else {\n      el.innerHTML = this.convertLineBreaks(this.props.escapeHtml ? escapeHtml(markup) : markup);\n    }\n\n    return el;\n  }\n  /**\n   * Convert an elements attribute map to an object map.\n   * Returns null if no attributes are defined.\n   */\n\n\n  extractAttributes(node) {\n    const {\n      allowAttributes\n    } = this.props;\n    const attributes = {};\n    let count = 0;\n\n    if (node.nodeType !== ELEMENT_NODE || !node.attributes) {\n      return null;\n    } // @ts-expect-error Cant type iterator\n\n\n    [...node.attributes].forEach(attr => {\n      const {\n        name,\n        value\n      } = attr;\n      const newName = name.toLowerCase();\n      const filter = ATTRIBUTES[newName] || ATTRIBUTES[name]; // Verify the node is safe from attacks\n\n      if (!this.isSafe(node)) {\n        return;\n      } // Do not allow denied attributes, excluding ARIA attributes\n      // Do not allow events or XSS injections\n\n\n      if (!newName.match(ALLOWED_ATTRS) && (!allowAttributes && (!filter || filter === FILTER_DENY) || newName.startsWith('on') || value.replace(/(\\s|\\0|&#x0([9AD]);)/, '').match(/(javascript|vbscript|livescript|xss):/i))) {\n        return;\n      } // Apply attribute filters\n\n\n      let newValue = newName === 'style' ? this.extractStyleAttribute(node) : value; // Cast to boolean\n\n      if (filter === FILTER_CAST_BOOL) {\n        newValue = true; // Cast to number\n      } else if (filter === FILTER_CAST_NUMBER) {\n        newValue = Number.parseFloat(String(newValue)); // Cast to string\n      } else if (filter !== FILTER_NO_CAST) {\n        newValue = String(newValue);\n      }\n\n      attributes[ATTRIBUTES_TO_PROPS[newName] || newName] = this.applyAttributeFilters(newName, newValue);\n      count += 1;\n    });\n\n    if (count === 0) {\n      return null;\n    }\n\n    return attributes;\n  }\n  /**\n   * Extract the style attribute as an object and remove values that allow for attack vectors.\n   */\n\n\n  extractStyleAttribute(node) {\n    const styles = {}; // eslint-disable-next-line unicorn/prefer-spread\n\n    Array.from(node.style).forEach(key => {\n      const value = node.style[key];\n\n      if (typeof value === 'string' || typeof value === 'number') {\n        styles[key.replace(/-([a-z])/g, (match, letter) => String(letter).toUpperCase())] = value;\n      }\n    });\n    return styles;\n  }\n  /**\n   * Return configuration for a specific tag.\n   */\n\n\n  getTagConfig(tagName) {\n    const common = {\n      children: [],\n      content: 0,\n      invalid: [],\n      parent: [],\n      self: true,\n      tagName: '',\n      type: 0,\n      void: false\n    }; // Only spread when a tag config exists,\n    // otherwise we use the empty `tagName`\n    // for parent config inheritance.\n\n    if (TAGS[tagName]) {\n      return { ...common,\n        ...TAGS[tagName],\n        tagName\n      };\n    }\n\n    return common;\n  }\n  /**\n   * Verify that a node is safe from XSS and injection attacks.\n   */\n\n\n  isSafe(node) {\n    // URLs should only support HTTP, email and phone numbers\n    if (typeof HTMLAnchorElement !== 'undefined' && node instanceof HTMLAnchorElement) {\n      const href = node.getAttribute('href'); // Fragment protocols start with about:\n      // So let's just allow them\n\n      if (href !== null && href !== void 0 && href.startsWith('#')) {\n        return true;\n      }\n\n      const protocol = node.protocol.toLowerCase();\n      return protocol === ':' || protocol === 'http:' || protocol === 'https:' || protocol === 'mailto:' || protocol === 'tel:';\n    }\n\n    return true;\n  }\n  /**\n   * Verify that an HTML tag is allowed to render.\n   */\n\n\n  isTagAllowed(tagName) {\n    if (this.banned.has(tagName) || this.blocked.has(tagName)) {\n      return false;\n    } // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n\n\n    return this.props.allowElements || this.allowed.has(tagName);\n  }\n  /**\n   * Parse the markup by injecting it into a detached document,\n   * while looping over all child nodes and generating an\n   * array to interpolate into JSX.\n   */\n\n\n  parse() {\n    if (!this.container) {\n      return [];\n    }\n\n    return this.parseNode(this.container, this.getTagConfig(this.container.nodeName.toLowerCase()));\n  }\n  /**\n   * Loop over the nodes children and generate a\n   * list of text nodes and React elements.\n   */\n\n\n  parseNode(parentNode, parentConfig) {\n    const {\n      noHtml,\n      noHtmlExceptMatchers,\n      allowElements,\n      transform,\n      transformOnlyAllowList\n    } = this.props;\n    let content = [];\n    let mergedText = ''; // @ts-expect-error Cant type iterator\n\n    [...parentNode.childNodes].forEach(node => {\n      // Create React elements from HTML elements\n      if (node.nodeType === ELEMENT_NODE) {\n        const tagName = node.nodeName.toLowerCase();\n        const config = this.getTagConfig(tagName); // Persist any previous text\n\n        if (mergedText) {\n          content.push(mergedText);\n          mergedText = '';\n        } // Apply node filters first\n\n\n        const nextNode = this.applyNodeFilters(tagName, node);\n\n        if (!nextNode) {\n          return;\n        } // Apply transformation second\n\n\n        let children;\n\n        if (transform && !(transformOnlyAllowList && !this.isTagAllowed(tagName))) {\n          this.keyIndex += 1;\n          const key = this.keyIndex; // Must occur after key is set\n\n          children = this.parseNode(nextNode, config);\n          const transformed = transform(nextNode, children, config);\n\n          if (transformed === null) {\n            return;\n          }\n\n          if (typeof transformed !== 'undefined') {\n            content.push( /*#__PURE__*/React.cloneElement(transformed, {\n              key\n            }));\n            return;\n          } // Reset as we're not using the transformation\n\n\n          this.keyIndex = key - 1;\n        } // Never allow these tags (except via a transformer)\n\n\n        if (this.banned.has(tagName)) {\n          return;\n        } // Only render when the following criteria is met:\n        //  - HTML has not been disabled\n        //  - Tag is allowed\n        //  - Child is valid within the parent\n\n\n        if (!(noHtml || noHtmlExceptMatchers && tagName !== 'br') && this.isTagAllowed(tagName) && (allowElements || this.canRenderChild(parentConfig, config))) {\n          var _children;\n\n          this.keyIndex += 1; // Build the props as it makes it easier to test\n\n          const attributes = this.extractAttributes(nextNode);\n          const elementProps = {\n            tagName\n          };\n\n          if (attributes) {\n            elementProps.attributes = attributes;\n          }\n\n          if (config.void) {\n            elementProps.selfClose = config.void;\n          }\n\n          content.push( /*#__PURE__*/React.createElement(Element, { ...elementProps,\n            key: this.keyIndex\n          }, (_children = children) !== null && _children !== void 0 ? _children : this.parseNode(nextNode, config))); // Render the children of the current element only.\n          // Important: If the current element is not allowed,\n          // use the parent element for the next scope.\n        } else {\n          content = [...content, ...this.parseNode(nextNode, config.tagName ? config : parentConfig)];\n        } // Apply matchers if a text node\n\n      } else if (node.nodeType === TEXT_NODE) {\n        const text = noHtml && !noHtmlExceptMatchers ? node.textContent : // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n        this.applyMatchers(node.textContent || '', parentConfig);\n\n        if (Array.isArray(text)) {\n          content = [...content, ...text];\n        } else {\n          mergedText += text;\n        }\n      }\n    });\n\n    if (mergedText) {\n      content.push(mergedText);\n    }\n\n    return content;\n  }\n  /**\n   * Deconstruct the string into an array, by replacing custom tokens with React elements,\n   * so that React can render it correctly.\n   */\n\n\n  replaceTokens(tokenizedString, elements) {\n    if (!tokenizedString.includes('{{{')) {\n      return tokenizedString;\n    }\n\n    const nodes = [];\n    let text = tokenizedString;\n    let open = null; // Find an open token tag\n\n    while (open = text.match(OPEN_TOKEN)) {\n      const [match, tokenName] = open;\n      const startIndex = open.index;\n      const isVoid = match.includes('/');\n\n      if (process.env.NODE_ENV !== \"production\" && !elements[tokenName]) {\n        throw new Error(`Token \"${tokenName}\" found but no matching element to replace with.`);\n      } // Extract the previous non-token text\n\n\n      if (startIndex > 0) {\n        nodes.push(text.slice(0, startIndex)); // Reduce text so that the closing tag will be found after the opening\n\n        text = text.slice(startIndex);\n      }\n\n      const {\n        children,\n        matcher,\n        props: elementProps\n      } = elements[tokenName];\n      let endIndex; // Use tag as-is if void\n\n      if (isVoid) {\n        endIndex = match.length;\n        nodes.push(matcher.createElement(children, elementProps)); // Find the closing tag if not void\n      } else {\n        const close = text.match(new RegExp(`{{{/${tokenName}}}}`));\n\n        if (process.env.NODE_ENV !== \"production\" && !close) {\n          throw new Error(`Closing token missing for interpolated element \"${tokenName}\".`);\n        }\n\n        endIndex = close.index + close[0].length;\n        nodes.push(matcher.createElement(this.replaceTokens(text.slice(match.length, close.index), elements), elementProps));\n      } // Reduce text for the next interation\n\n\n      text = text.slice(endIndex);\n    } // Extra the remaining text\n\n\n    if (text.length > 0) {\n      nodes.push(text);\n    } // Reduce to a string if possible\n\n\n    if (nodes.length === 0) {\n      return '';\n    }\n\n    if (nodes.length === 1 && typeof nodes[0] === 'string') {\n      return nodes[0];\n    }\n\n    return nodes;\n  }\n\n}\n/* eslint-disable react/jsx-fragments */\n\n\nfunction Markup(props) {\n  var _ref;\n\n  const {\n    attributes,\n    className,\n    containerTagName,\n    content,\n    emptyContent,\n    parsedContent,\n    tagName,\n    noWrap: baseNoWrap\n  } = props;\n  const tag = (_ref = containerTagName !== null && containerTagName !== void 0 ? containerTagName : tagName) !== null && _ref !== void 0 ? _ref : 'span';\n  const noWrap = tag === 'fragment' ? true : baseNoWrap;\n  let mainContent;\n\n  if (parsedContent) {\n    mainContent = parsedContent;\n  } else {\n    const markup = new Parser(content !== null && content !== void 0 ? content : '', props).parse();\n\n    if (markup.length > 0) {\n      mainContent = markup;\n    }\n  }\n\n  if (!mainContent) {\n    mainContent = emptyContent;\n  }\n\n  if (noWrap) {\n    // eslint-disable-next-line react/jsx-no-useless-fragment\n    return /*#__PURE__*/React.createElement(React.Fragment, null, mainContent);\n  }\n\n  return /*#__PURE__*/React.createElement(Element, {\n    attributes: attributes,\n    className: className,\n    tagName: tag\n  }, mainContent);\n}\n/* eslint-disable promise/prefer-await-to-callbacks */\n\n\nfunction Interweave(props) {\n  const {\n    attributes,\n    className,\n    content = '',\n    disableFilters = false,\n    disableMatchers = false,\n    emptyContent = null,\n    filters = [],\n    matchers = [],\n    onAfterParse = null,\n    onBeforeParse = null,\n    tagName = 'span',\n    noWrap = false,\n    ...parserProps\n  } = props;\n  const allMatchers = disableMatchers ? [] : matchers;\n  const allFilters = disableFilters ? [] : filters;\n  const beforeCallbacks = onBeforeParse ? [onBeforeParse] : [];\n  const afterCallbacks = onAfterParse ? [onAfterParse] : []; // Inherit callbacks from matchers\n\n  allMatchers.forEach(matcher => {\n    if (matcher.onBeforeParse) {\n      beforeCallbacks.push(matcher.onBeforeParse.bind(matcher));\n    }\n\n    if (matcher.onAfterParse) {\n      afterCallbacks.push(matcher.onAfterParse.bind(matcher));\n    }\n  }); // Trigger before callbacks\n\n  const markup = beforeCallbacks.reduce((string, callback) => {\n    const nextString = callback(string, props);\n\n    if (process.env.NODE_ENV !== \"production\" && typeof nextString !== 'string') {\n      throw new TypeError('Interweave `onBeforeParse` must return a valid HTML string.');\n    }\n\n    return nextString;\n  }, content !== null && content !== void 0 ? content : ''); // Parse the markup\n\n  const parser = new Parser(markup, parserProps, allMatchers, allFilters); // Trigger after callbacks\n\n  const nodes = afterCallbacks.reduce((parserNodes, callback) => {\n    const nextNodes = callback(parserNodes, props);\n\n    if (process.env.NODE_ENV !== \"production\" && !Array.isArray(nextNodes)) {\n      throw new TypeError('Interweave `onAfterParse` must return an array of strings and React elements.');\n    }\n\n    return nextNodes;\n  }, parser.parse());\n  return /*#__PURE__*/React.createElement(Markup, {\n    attributes: attributes,\n    className: className // eslint-disable-next-line react/destructuring-assignment\n    ,\n    containerTagName: props.containerTagName,\n    emptyContent: emptyContent,\n    noWrap: noWrap,\n    parsedContent: nodes.length === 0 ? undefined : nodes,\n    tagName: tagName\n  });\n}\n\nexport { Interweave, Markup, Parser };","map":{"version":3,"sources":["../src/StyleFilter.ts","../src/Parser.ts","../src/Markup.tsx","../src/Interweave.tsx"],"names":["attribute","name","Object","key","String","value","TEXT_NODE","INVALID_ROOTS","ALLOWED_ATTRS","OPEN_TOKEN","allowed","banned","blocked","content","matchers","keyIndex","constructor","markup","TypeError","props","applyAttributeFilters","applyNodeFilters","applyMatchers","string","parentConfig","matcher","canRenderChild","match","void","tokenizedString","elementIndex","elements","children","greedy","matchedString","childConfig","noHtml","disableLineBreaks","nextMarkup","factory","global","extractAttributes","allowAttributes","filter","newValue","newName","extractStyleAttribute","FILTER_CAST_BOOL","attributes","Array","styles","getTagConfig","tagName","self","TAGS","isSafe","isTagAllowed","parse","parseNode","transform","transformOnlyAllowList","node","mergedText","elementProps","replaceTokens","nodes","push","text","endIndex","length","emptyContent","noWrap","mainContent","className","disableFilters","onAfterParse","onBeforeParse","afterCallbacks","allMatchers","beforeCallbacks","nextString","parser","isArray","nextNodes"],"mappings":"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","sourcesContent":["function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Bundled with Packemon: https://packemon.dev\n// Platform: browser, Support: stable, Format: esm\nimport { F as Filter, A as ALLOWED_TAG_LIST, B as BANNED_TAG_LIST, a as ATTRIBUTES, b as FILTER_DENY, c as ATTRIBUTES_TO_PROPS, T as TAGS, E as Element, d as FILTER_CAST_BOOL, e as FILTER_CAST_NUMBER, f as FILTER_NO_CAST } from './bundle-94421b73.js';\nexport { A as ALLOWED_TAG_LIST, a as ATTRIBUTES, c as ATTRIBUTES_TO_PROPS, B as BANNED_TAG_LIST, E as Element, n as FILTER_ALLOW, d as FILTER_CAST_BOOL, e as FILTER_CAST_NUMBER, b as FILTER_DENY, f as FILTER_NO_CAST, F as Filter, M as Matcher, T as TAGS, k as TYPE_EMBEDDED, g as TYPE_FLOW, i as TYPE_HEADING, l as TYPE_INTERACTIVE, m as TYPE_PALPABLE, j as TYPE_PHRASING, h as TYPE_SECTION, o as match } from './bundle-94421b73.js';\nimport React from 'react';\nimport escapeHtml from 'escape-html';\nconst INVALID_STYLES = /(url|image|image-set)\\(/i;\n\nclass StyleFilter extends Filter {\n  attribute(name, value) {\n    if (name === 'style') {\n      Object.keys(value).forEach(key => {\n        if (String(value[key]).match(INVALID_STYLES)) {\n          // eslint-disable-next-line no-param-reassign\n          delete value[key];\n        }\n      });\n    } // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n\n\n    return value;\n  }\n\n}\n/* eslint-disable no-bitwise, no-cond-assign, complexity, @typescript-eslint/no-unsafe-return */\n\n\nconst ELEMENT_NODE = 1;\nconst TEXT_NODE = 3;\nconst INVALID_ROOTS = /^<(!doctype|(html|head|body)(\\s|>))/i;\nconst ALLOWED_ATTRS = /^(aria-|data-|\\w+:)/iu;\nconst OPEN_TOKEN = /{{{(\\w+)\\/?}}}/;\n\nfunction createDocument() {\n  // Maybe SSR? Just do nothing instead of crashing!\n  if (typeof window === 'undefined' || typeof document === 'undefined') {\n    return undefined;\n  }\n\n  return document.implementation.createHTMLDocument('Interweave');\n}\n\nclass Parser {\n  constructor(markup, props = {}, matchers = [], filters = []) {\n    var _props$allowList;\n\n    _defineProperty(this, \"allowed\", void 0);\n\n    _defineProperty(this, \"banned\", void 0);\n\n    _defineProperty(this, \"blocked\", void 0);\n\n    _defineProperty(this, \"container\", void 0);\n\n    _defineProperty(this, \"content\", []);\n\n    _defineProperty(this, \"props\", void 0);\n\n    _defineProperty(this, \"matchers\", void 0);\n\n    _defineProperty(this, \"filters\", void 0);\n\n    _defineProperty(this, \"keyIndex\", void 0);\n\n    if (process.env.NODE_ENV !== \"production\" && markup && typeof markup !== 'string') {\n      throw new TypeError('Interweave parser requires a valid string.');\n    }\n\n    this.props = props;\n    this.matchers = matchers;\n    this.filters = [...filters, new StyleFilter()];\n    this.keyIndex = -1;\n    this.container = this.createContainer(markup || '');\n    this.allowed = new Set((_props$allowList = props.allowList) !== null && _props$allowList !== void 0 ? _props$allowList : ALLOWED_TAG_LIST);\n    this.banned = new Set(BANNED_TAG_LIST);\n    this.blocked = new Set(props.blockList);\n  }\n  /**\n   * Loop through and apply all registered attribute filters.\n   */\n\n\n  applyAttributeFilters(name, value) {\n    return this.filters.reduce((nextValue, filter) => nextValue !== null && typeof filter.attribute === 'function' ? filter.attribute(name, nextValue) : nextValue, value);\n  }\n  /**\n   * Loop through and apply all registered node filters.\n   */\n\n\n  applyNodeFilters(name, node) {\n    // Allow null to be returned\n    return this.filters.reduce((nextNode, filter) => nextNode !== null && typeof filter.node === 'function' ? filter.node(name, nextNode) : nextNode, node);\n  }\n  /**\n   * Loop through and apply all registered matchers to the string.\n   * If a match is found, create a React element, and build a new array.\n   * This array allows React to interpolate and render accordingly.\n   */\n\n\n  applyMatchers(string, parentConfig) {\n    const elements = {};\n    const {\n      props\n    } = this;\n    let matchedString = string;\n    let elementIndex = 0;\n    let parts = null;\n    this.matchers.forEach(matcher => {\n      const tagName = matcher.asTag().toLowerCase();\n      const config = this.getTagConfig(tagName); // Skip matchers that have been disabled from props or are not supported\n\n      if (props[matcher.inverseName] || !this.isTagAllowed(tagName)) {\n        return;\n      } // Skip matchers in which the child cannot be rendered\n\n\n      if (!this.canRenderChild(parentConfig, config)) {\n        return;\n      } // Continuously trigger the matcher until no matches are found\n\n\n      let tokenizedString = '';\n\n      while (matchedString && (parts = matcher.match(matchedString))) {\n        const {\n          index,\n          length,\n          match,\n          valid,\n          void: isVoid,\n          ...partProps\n        } = parts;\n        const tokenName = matcher.propName + String(elementIndex); // Piece together a new string with interpolated tokens\n\n        if (index > 0) {\n          tokenizedString += matchedString.slice(0, index);\n        }\n\n        if (valid) {\n          tokenizedString += isVoid ? `{{{${tokenName}/}}}` : `{{{${tokenName}}}}${match}{{{/${tokenName}}}}`;\n          this.keyIndex += 1;\n          elementIndex += 1;\n          elements[tokenName] = {\n            children: match,\n            matcher,\n            props: { ...props,\n              ...partProps,\n              key: this.keyIndex\n            }\n          };\n        } else {\n          tokenizedString += match;\n        } // Reduce the string being matched against,\n        // otherwise we end up in an infinite loop!\n\n\n        if (matcher.greedy) {\n          matchedString = tokenizedString + matchedString.slice(index + length);\n          tokenizedString = '';\n        } else {\n          // eslint-disable-next-line unicorn/explicit-length-check\n          matchedString = matchedString.slice(index + (length || match.length));\n        }\n      } // Update the matched string with the tokenized string,\n      // so that the next matcher can apply to it.\n\n\n      if (!matcher.greedy) {\n        matchedString = tokenizedString + matchedString;\n      }\n    });\n\n    if (elementIndex === 0) {\n      return string;\n    }\n\n    return this.replaceTokens(matchedString, elements);\n  }\n  /**\n   * Determine whether the child can be rendered within the parent.\n   */\n\n\n  canRenderChild(parentConfig, childConfig) {\n    if (!parentConfig.tagName || !childConfig.tagName) {\n      return false;\n    } // No children\n\n\n    if (parentConfig.void) {\n      return false;\n    } // Valid children\n\n\n    if (parentConfig.children.length > 0) {\n      return parentConfig.children.includes(childConfig.tagName);\n    }\n\n    if (parentConfig.invalid.length > 0 && parentConfig.invalid.includes(childConfig.tagName)) {\n      return false;\n    } // Valid parent\n\n\n    if (childConfig.parent.length > 0) {\n      return childConfig.parent.includes(parentConfig.tagName);\n    } // Self nesting\n\n\n    if (!parentConfig.self && parentConfig.tagName === childConfig.tagName) {\n      return false;\n    } // Content category type\n\n\n    return Boolean(parentConfig && parentConfig.content & childConfig.type);\n  }\n  /**\n   * Convert line breaks in a string to HTML `<br/>` tags.\n   * If the string contains HTML, we should not convert anything,\n   * as line breaks should be handled by `<br/>`s in the markup itself.\n   */\n\n\n  convertLineBreaks(markup) {\n    const {\n      noHtml,\n      disableLineBreaks\n    } = this.props;\n\n    if (noHtml || disableLineBreaks || markup.match(/<((?:\\/[ a-z]+)|(?:[ a-z]+\\/))>/gi)) {\n      return markup;\n    } // Replace carriage returns\n\n\n    let nextMarkup = markup.replace(/\\r\\n/g, '\\n'); // Replace long line feeds\n\n    nextMarkup = nextMarkup.replace(/\\n{3,}/g, '\\n\\n\\n'); // Replace line feeds with `<br/>`s\n\n    nextMarkup = nextMarkup.replace(/\\n/g, '<br/>');\n    return nextMarkup;\n  }\n  /**\n   * Create a detached HTML document that allows for easy HTML\n   * parsing while not triggering scripts or loading external\n   * resources.\n   */\n\n\n  createContainer(markup) {\n    var _this$props$container;\n\n    const factory = typeof global !== 'undefined' && global.INTERWEAVE_SSR_POLYFILL || createDocument;\n    const doc = factory();\n\n    if (!doc) {\n      return undefined;\n    }\n\n    const tag = (_this$props$container = this.props.containerTagName) !== null && _this$props$container !== void 0 ? _this$props$container : 'body';\n    const el = tag === 'body' || tag === 'fragment' ? doc.body : doc.createElement(tag);\n\n    if (markup.match(INVALID_ROOTS)) {\n      if (process.env.NODE_ENV !== \"production\") {\n        throw new Error('HTML documents as Interweave content are not supported.');\n      }\n    } else {\n      el.innerHTML = this.convertLineBreaks(this.props.escapeHtml ? escapeHtml(markup) : markup);\n    }\n\n    return el;\n  }\n  /**\n   * Convert an elements attribute map to an object map.\n   * Returns null if no attributes are defined.\n   */\n\n\n  extractAttributes(node) {\n    const {\n      allowAttributes\n    } = this.props;\n    const attributes = {};\n    let count = 0;\n\n    if (node.nodeType !== ELEMENT_NODE || !node.attributes) {\n      return null;\n    } // @ts-expect-error Cant type iterator\n\n\n    [...node.attributes].forEach(attr => {\n      const {\n        name,\n        value\n      } = attr;\n      const newName = name.toLowerCase();\n      const filter = ATTRIBUTES[newName] || ATTRIBUTES[name]; // Verify the node is safe from attacks\n\n      if (!this.isSafe(node)) {\n        return;\n      } // Do not allow denied attributes, excluding ARIA attributes\n      // Do not allow events or XSS injections\n\n\n      if (!newName.match(ALLOWED_ATTRS) && (!allowAttributes && (!filter || filter === FILTER_DENY) || newName.startsWith('on') || value.replace(/(\\s|\\0|&#x0([9AD]);)/, '').match(/(javascript|vbscript|livescript|xss):/i))) {\n        return;\n      } // Apply attribute filters\n\n\n      let newValue = newName === 'style' ? this.extractStyleAttribute(node) : value; // Cast to boolean\n\n      if (filter === FILTER_CAST_BOOL) {\n        newValue = true; // Cast to number\n      } else if (filter === FILTER_CAST_NUMBER) {\n        newValue = Number.parseFloat(String(newValue)); // Cast to string\n      } else if (filter !== FILTER_NO_CAST) {\n        newValue = String(newValue);\n      }\n\n      attributes[ATTRIBUTES_TO_PROPS[newName] || newName] = this.applyAttributeFilters(newName, newValue);\n      count += 1;\n    });\n\n    if (count === 0) {\n      return null;\n    }\n\n    return attributes;\n  }\n  /**\n   * Extract the style attribute as an object and remove values that allow for attack vectors.\n   */\n\n\n  extractStyleAttribute(node) {\n    const styles = {}; // eslint-disable-next-line unicorn/prefer-spread\n\n    Array.from(node.style).forEach(key => {\n      const value = node.style[key];\n\n      if (typeof value === 'string' || typeof value === 'number') {\n        styles[key.replace(/-([a-z])/g, (match, letter) => String(letter).toUpperCase())] = value;\n      }\n    });\n    return styles;\n  }\n  /**\n   * Return configuration for a specific tag.\n   */\n\n\n  getTagConfig(tagName) {\n    const common = {\n      children: [],\n      content: 0,\n      invalid: [],\n      parent: [],\n      self: true,\n      tagName: '',\n      type: 0,\n      void: false\n    }; // Only spread when a tag config exists,\n    // otherwise we use the empty `tagName`\n    // for parent config inheritance.\n\n    if (TAGS[tagName]) {\n      return { ...common,\n        ...TAGS[tagName],\n        tagName\n      };\n    }\n\n    return common;\n  }\n  /**\n   * Verify that a node is safe from XSS and injection attacks.\n   */\n\n\n  isSafe(node) {\n    // URLs should only support HTTP, email and phone numbers\n    if (typeof HTMLAnchorElement !== 'undefined' && node instanceof HTMLAnchorElement) {\n      const href = node.getAttribute('href'); // Fragment protocols start with about:\n      // So let's just allow them\n\n      if (href !== null && href !== void 0 && href.startsWith('#')) {\n        return true;\n      }\n\n      const protocol = node.protocol.toLowerCase();\n      return protocol === ':' || protocol === 'http:' || protocol === 'https:' || protocol === 'mailto:' || protocol === 'tel:';\n    }\n\n    return true;\n  }\n  /**\n   * Verify that an HTML tag is allowed to render.\n   */\n\n\n  isTagAllowed(tagName) {\n    if (this.banned.has(tagName) || this.blocked.has(tagName)) {\n      return false;\n    } // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n\n\n    return this.props.allowElements || this.allowed.has(tagName);\n  }\n  /**\n   * Parse the markup by injecting it into a detached document,\n   * while looping over all child nodes and generating an\n   * array to interpolate into JSX.\n   */\n\n\n  parse() {\n    if (!this.container) {\n      return [];\n    }\n\n    return this.parseNode(this.container, this.getTagConfig(this.container.nodeName.toLowerCase()));\n  }\n  /**\n   * Loop over the nodes children and generate a\n   * list of text nodes and React elements.\n   */\n\n\n  parseNode(parentNode, parentConfig) {\n    const {\n      noHtml,\n      noHtmlExceptMatchers,\n      allowElements,\n      transform,\n      transformOnlyAllowList\n    } = this.props;\n    let content = [];\n    let mergedText = ''; // @ts-expect-error Cant type iterator\n\n    [...parentNode.childNodes].forEach(node => {\n      // Create React elements from HTML elements\n      if (node.nodeType === ELEMENT_NODE) {\n        const tagName = node.nodeName.toLowerCase();\n        const config = this.getTagConfig(tagName); // Persist any previous text\n\n        if (mergedText) {\n          content.push(mergedText);\n          mergedText = '';\n        } // Apply node filters first\n\n\n        const nextNode = this.applyNodeFilters(tagName, node);\n\n        if (!nextNode) {\n          return;\n        } // Apply transformation second\n\n\n        let children;\n\n        if (transform && !(transformOnlyAllowList && !this.isTagAllowed(tagName))) {\n          this.keyIndex += 1;\n          const key = this.keyIndex; // Must occur after key is set\n\n          children = this.parseNode(nextNode, config);\n          const transformed = transform(nextNode, children, config);\n\n          if (transformed === null) {\n            return;\n          }\n\n          if (typeof transformed !== 'undefined') {\n            content.push( /*#__PURE__*/React.cloneElement(transformed, {\n              key\n            }));\n            return;\n          } // Reset as we're not using the transformation\n\n\n          this.keyIndex = key - 1;\n        } // Never allow these tags (except via a transformer)\n\n\n        if (this.banned.has(tagName)) {\n          return;\n        } // Only render when the following criteria is met:\n        //  - HTML has not been disabled\n        //  - Tag is allowed\n        //  - Child is valid within the parent\n\n\n        if (!(noHtml || noHtmlExceptMatchers && tagName !== 'br') && this.isTagAllowed(tagName) && (allowElements || this.canRenderChild(parentConfig, config))) {\n          var _children;\n\n          this.keyIndex += 1; // Build the props as it makes it easier to test\n\n          const attributes = this.extractAttributes(nextNode);\n          const elementProps = {\n            tagName\n          };\n\n          if (attributes) {\n            elementProps.attributes = attributes;\n          }\n\n          if (config.void) {\n            elementProps.selfClose = config.void;\n          }\n\n          content.push( /*#__PURE__*/React.createElement(Element, { ...elementProps,\n            key: this.keyIndex\n          }, (_children = children) !== null && _children !== void 0 ? _children : this.parseNode(nextNode, config))); // Render the children of the current element only.\n          // Important: If the current element is not allowed,\n          // use the parent element for the next scope.\n        } else {\n          content = [...content, ...this.parseNode(nextNode, config.tagName ? config : parentConfig)];\n        } // Apply matchers if a text node\n\n      } else if (node.nodeType === TEXT_NODE) {\n        const text = noHtml && !noHtmlExceptMatchers ? node.textContent : // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n        this.applyMatchers(node.textContent || '', parentConfig);\n\n        if (Array.isArray(text)) {\n          content = [...content, ...text];\n        } else {\n          mergedText += text;\n        }\n      }\n    });\n\n    if (mergedText) {\n      content.push(mergedText);\n    }\n\n    return content;\n  }\n  /**\n   * Deconstruct the string into an array, by replacing custom tokens with React elements,\n   * so that React can render it correctly.\n   */\n\n\n  replaceTokens(tokenizedString, elements) {\n    if (!tokenizedString.includes('{{{')) {\n      return tokenizedString;\n    }\n\n    const nodes = [];\n    let text = tokenizedString;\n    let open = null; // Find an open token tag\n\n    while (open = text.match(OPEN_TOKEN)) {\n      const [match, tokenName] = open;\n      const startIndex = open.index;\n      const isVoid = match.includes('/');\n\n      if (process.env.NODE_ENV !== \"production\" && !elements[tokenName]) {\n        throw new Error(`Token \"${tokenName}\" found but no matching element to replace with.`);\n      } // Extract the previous non-token text\n\n\n      if (startIndex > 0) {\n        nodes.push(text.slice(0, startIndex)); // Reduce text so that the closing tag will be found after the opening\n\n        text = text.slice(startIndex);\n      }\n\n      const {\n        children,\n        matcher,\n        props: elementProps\n      } = elements[tokenName];\n      let endIndex; // Use tag as-is if void\n\n      if (isVoid) {\n        endIndex = match.length;\n        nodes.push(matcher.createElement(children, elementProps)); // Find the closing tag if not void\n      } else {\n        const close = text.match(new RegExp(`{{{/${tokenName}}}}`));\n\n        if (process.env.NODE_ENV !== \"production\" && !close) {\n          throw new Error(`Closing token missing for interpolated element \"${tokenName}\".`);\n        }\n\n        endIndex = close.index + close[0].length;\n        nodes.push(matcher.createElement(this.replaceTokens(text.slice(match.length, close.index), elements), elementProps));\n      } // Reduce text for the next interation\n\n\n      text = text.slice(endIndex);\n    } // Extra the remaining text\n\n\n    if (text.length > 0) {\n      nodes.push(text);\n    } // Reduce to a string if possible\n\n\n    if (nodes.length === 0) {\n      return '';\n    }\n\n    if (nodes.length === 1 && typeof nodes[0] === 'string') {\n      return nodes[0];\n    }\n\n    return nodes;\n  }\n\n}\n/* eslint-disable react/jsx-fragments */\n\n\nfunction Markup(props) {\n  var _ref;\n\n  const {\n    attributes,\n    className,\n    containerTagName,\n    content,\n    emptyContent,\n    parsedContent,\n    tagName,\n    noWrap: baseNoWrap\n  } = props;\n  const tag = (_ref = containerTagName !== null && containerTagName !== void 0 ? containerTagName : tagName) !== null && _ref !== void 0 ? _ref : 'span';\n  const noWrap = tag === 'fragment' ? true : baseNoWrap;\n  let mainContent;\n\n  if (parsedContent) {\n    mainContent = parsedContent;\n  } else {\n    const markup = new Parser(content !== null && content !== void 0 ? content : '', props).parse();\n\n    if (markup.length > 0) {\n      mainContent = markup;\n    }\n  }\n\n  if (!mainContent) {\n    mainContent = emptyContent;\n  }\n\n  if (noWrap) {\n    // eslint-disable-next-line react/jsx-no-useless-fragment\n    return /*#__PURE__*/React.createElement(React.Fragment, null, mainContent);\n  }\n\n  return /*#__PURE__*/React.createElement(Element, {\n    attributes: attributes,\n    className: className,\n    tagName: tag\n  }, mainContent);\n}\n/* eslint-disable promise/prefer-await-to-callbacks */\n\n\nfunction Interweave(props) {\n  const {\n    attributes,\n    className,\n    content = '',\n    disableFilters = false,\n    disableMatchers = false,\n    emptyContent = null,\n    filters = [],\n    matchers = [],\n    onAfterParse = null,\n    onBeforeParse = null,\n    tagName = 'span',\n    noWrap = false,\n    ...parserProps\n  } = props;\n  const allMatchers = disableMatchers ? [] : matchers;\n  const allFilters = disableFilters ? [] : filters;\n  const beforeCallbacks = onBeforeParse ? [onBeforeParse] : [];\n  const afterCallbacks = onAfterParse ? [onAfterParse] : []; // Inherit callbacks from matchers\n\n  allMatchers.forEach(matcher => {\n    if (matcher.onBeforeParse) {\n      beforeCallbacks.push(matcher.onBeforeParse.bind(matcher));\n    }\n\n    if (matcher.onAfterParse) {\n      afterCallbacks.push(matcher.onAfterParse.bind(matcher));\n    }\n  }); // Trigger before callbacks\n\n  const markup = beforeCallbacks.reduce((string, callback) => {\n    const nextString = callback(string, props);\n\n    if (process.env.NODE_ENV !== \"production\" && typeof nextString !== 'string') {\n      throw new TypeError('Interweave `onBeforeParse` must return a valid HTML string.');\n    }\n\n    return nextString;\n  }, content !== null && content !== void 0 ? content : ''); // Parse the markup\n\n  const parser = new Parser(markup, parserProps, allMatchers, allFilters); // Trigger after callbacks\n\n  const nodes = afterCallbacks.reduce((parserNodes, callback) => {\n    const nextNodes = callback(parserNodes, props);\n\n    if (process.env.NODE_ENV !== \"production\" && !Array.isArray(nextNodes)) {\n      throw new TypeError('Interweave `onAfterParse` must return an array of strings and React elements.');\n    }\n\n    return nextNodes;\n  }, parser.parse());\n  return /*#__PURE__*/React.createElement(Markup, {\n    attributes: attributes,\n    className: className // eslint-disable-next-line react/destructuring-assignment\n    ,\n    containerTagName: props.containerTagName,\n    emptyContent: emptyContent,\n    noWrap: noWrap,\n    parsedContent: nodes.length === 0 ? undefined : nodes,\n    tagName: tagName\n  });\n}\n\nexport { Interweave, Markup, Parser };\n//# sourceMappingURL=index.js.map\n"]},"metadata":{},"sourceType":"module"}